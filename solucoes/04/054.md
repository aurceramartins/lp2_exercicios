## Problema

54 - Explica, por palavras tuas, o que significa invariância, co-variância e
contra-variância em genéricos. Indica quais são os operadores utilizados para
especificar o tipo de variância, em que tipos podem ser usados, e apresenta
exemplos dos três casos na API do C#.

## Soluçoes

### Solução 1

- Invariância: É a regra por defeito da Variância, se nao o especificamos nao 
existe nenhum tipo de hierarquia entre tipos genericos, so podemos utilizar o
tipo especificado originalmente coma no caso do List por ejemplo nao podemos 
relacionar um List<T> com um List<T1>
(List<Carros> list = new List<Mercedes>(); nao e posivel fazer isto).

- Co-variância: Se o tipo generico e usado apenas como saída (metodos com return,
get ou indexadores) entao poderemos utilizar um tipo mais derivado que o especificado
originalmente, TipoGenerico<Carros> carro= new TipoGenerico<Mercedes>();
nao podemos usar os tipos que aceitem entradas como o List<T> que tem o metodo Add();
podemos usar co-variância no IEnumerable<T> por ejemplo.

- Contra-variância: Este caso e todo o contrario, so aceita tipos genericos de entrada
(Parametros de metodos, set ou indexadores) nestes casos podemos utiliçar relaçoes
invertidas TipoGenerico<Mercedes> m = new TipoGenerico<Carros>();
Podemos utilizar contra-variância no Action<T>.


##Exemplo de Co-variância:

```cs
using System;
using System.Collections.Generic;

class Base
{
    public static void PrintBases(IEnumerable<Base> bases)
    {
        foreach(Base b in bases)
        {
            Console.WriteLine(b);
        }
    }
}

class Derived : Base
{
    public static void Main()
    {
        List<Derived> dlist = new List<Derived>();

        Derived.PrintBases(dlist);
        IEnumerable<Base> bIEnum = dlist;
    }
}

```


##Exemplo de Contra-variância:
```cs
using System;
using System.Collections.Generic;

abstract class Shape
{
    public virtual double Area { get { return 0; }}
}

class Circle : Shape
{
    private double r;
    public Circle(double radius) { r = radius; }
    public double Radius { get { return r; }}
    public override double Area { get { return Math.PI * r * r; }}
}

class ShapeAreaComparer : System.Collections.Generic.IComparer<Shape>
{
    int IComparer<Shape>.Compare(Shape a, Shape b) 
    { 
        if (a == null) return b == null ? 0 : -1;
        return b == null ? 1 : a.Area.CompareTo(b.Area);
    }
}

class Program
{
    static void Main()
    {
        // You can pass ShapeAreaComparer, which implements IComparer<Shape>,
        // even though the constructor for SortedSet<Circle> expects 
        // IComparer<Circle>, because type parameter T of IComparer<T> is
        // contravariant.
        SortedSet<Circle> circlesByArea = 
            new SortedSet<Circle>(new ShapeAreaComparer()) 
                { new Circle(7.2), new Circle(100), null, new Circle(.01) };

        foreach (Circle c in circlesByArea)
        {
            Console.WriteLine(c == null ? "null" : "Circle with area " + c.Area);
        }
    }
}

```